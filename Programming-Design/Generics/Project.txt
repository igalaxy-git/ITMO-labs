// обобщенный класс АТД “Список”
class AbstractList<T extends Comparable<T>>{
    private T[] list; // массив элементов заданного типа
    private int afterTheLast = 0; // номер после последнего

    // конструктор из массива
    public AbstractList(T[] list){
        this.list = list;
    }

    // Позиция после последнего
    public int End(){
        return afterTheLast;
    }

    // Вставка значения x в позицию p списка L
    public void Insert(T x, int p){
        // если позиция меньше нуля или больше позиции после последней, то ничего не делать
        // если в позицию после последнего, то добавить в конец
        // иначе цикл от позиции после последней до нужной (i--) list[i] = list[i-1]
        // после цикла list[p] = x;
        // afterTheLast увеличить на 1
    }

    // Позиция p значения x в списке L
    public int Locate(T x){
        // цикл по списку и сравнение значений (метод compareTo)
        // если в цикле есть равенство, то вернуть нужную позицию
        return afterTheLast;
    }

    // Значение позиции p списка L
    public T Retrieve(int p){
        // если позиция недействительна или это позиция после последнего, выбросить исключение
        // иначе вернуть list[p];
    }

    // Удаление значения позиции p списка L
    public void Delete(int p){
        // если позиция недействительна или это позиция после последнего, ничего не делать
        // иначе цикл от нужной позиции до конца (значение текущего элемента приравнивается значению следующего)
        // уменьшить afterTheLast на 1
    }

    // Позиция следующая за p в списке L
    public int Next(int p){
       if (p+1 > afterTheLast || p+1 < 0)
            throw new RuntimeException();
        return p+1;
    }

    // Предыдущая позиция за p в списке L
    public int Previous(int p){
        if (p-1 >= afterTheLast || p-1 < 0)
            throw new RuntimeException();
        return p-1;
    }

    // Опустошение списка
    public void MakeNull(){
        // позицию после последнего сделать нулевой
        afterTheLast = 0;
    }

    // Позиция первого элемента в списке
    public int First(){
        // вернуть 0
    }

    // Вывод на печать заполненной части списка L
    public void PrintList(){
        // цикл по списку
        for (int i = 0; i < afterTheLast; i++)
            System.out.print(list[i] + " ");
    }
}


// класс рациональных чисел
class Rational implements Comparable<Rational> {
    private int n; // числитель
    private int q; // знаменатель

    // конструктор из числителя и знаменателя
    public Rational(int n, int q) {
        this.n = n;
        this.q = q;
        // если q == 0, выбросить Arithmetic Exception
        // если числитель равен нулю, то знаменатель 1
        // иначе, сократить дробь (метод reduce)
    }

    // сокращение дроби
    private void reduce(){
        // если знаменатель меньше нуля, то домножить знаменатель и числитель на -1
        // найти наименьший общий делитель модулей этих чисел (метод NOD)
        // разделить числитель и знаменатель на НОД
    }

    // поиск наименьшего общего делителя
    private int NOD(int a, int b){
        while (a != b) {
            if (a > b) {
                a = a - b;
            } else {
                b = b - a;
            }
        }
        return a;
    }

    // сравнение с другим экземпляром класса
    public int compareTo(Rational x){
        // если a < b, вернуть значение меньше нуля
        // если a = b, вернуть 0
        // если a > b, вернуть значение больше нуля
        // значит вернуть результат вычитания этих двух дробей
        return (n*x.q)-(x.n*q);
    }

    // преобразование в строку
    public String toString(){
        // если числитель равен нулю, вернуть "0"
        // если знаменатель равен единице, вернуть числитель
        // если дробь сложная (Math.abs(n/q) >= 1), то вернуть результат деления + " " + остаток от деления + "/" + знаменатель
        // вернуть числитель + "/" + знаменатель
    }
}

// главный класс
public class Main {
    public static void main(String[] args){
        // создание и заполнение списков
        // удаление одинаковых элементов (метод deleteDupes)
    }

    // обобщенный статический метод удаления дубликатов из списка
    public static <T extends Comparable<T>> void deleteDupes(AbstractList<T> list){
        // Найти первую позицию в списке (метод First)
        // Пока эта позиция не равна последней (метод End)
            // Найти следующую позицию (метод Next)
            // Пока следующая позиция не равна последней (метод End)
                // Если значения на этих позициях равны (методы Retrieve и compareTo)
                    // Удалить повторение (метод Delete)
	        	// Иначе обновить следующую позицию (метод Next)
        	// Обновить текущую позицию (метод Next)
    }
}
