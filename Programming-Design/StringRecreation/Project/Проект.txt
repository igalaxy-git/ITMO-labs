//Реализовать класс строки: строка - связный список
public class ListString
{
    // Класс блока: узла связного списка
    private class StringItem
    {
        private final static int SIZE = 16; // размер символьного массива в блоке
        private char [] symbols; // символьный массив
        private StringItem next; // следующий блок
        private int size; // реальный размер символьного массива в блоке

        // Конструктор по умолчанию
        private StringItem()
        {
            1. Инициализация переменной symbols: выделение памяти
            2. Инициализация переменных next и size: null и 0
        }

        // Копирующий конструктор
        private StringItem(StringItem si)
        {
            1. Инициализация переменной symbols: выделение памяти
            2. Инициализация переменной size: размер переданного StringItem
            3. Инициализация переменной next: null
            4. Копирование si.symbols в symbols (метод copy)
        }

        // Совместить два соседних блока в один
        private void join()
        {
            1. Скопировать значения из следущего блока в текущий (метод copy)
            2. Обновить size
            3. Текущий next приравнивается следующему
        }

        // Разделить блок на два, начиная с index
        private void split(int index)
        {
            1. Создать новый блок
            2. Next нового блока приравнивается next текущего
            3. Next текущего приравнивается новому блоку
            4. У нового блока size = this.size - index
            5. this.size = index
            6. Скопировать значения, начиная с index, в следующий блок (метод copy)
        }
    }

    // Класс индекса: блок и позиция в нем
    private class Index
    {
        private StringItem si; //ссылка на блок
        private int position; //позиция элемента в массиве

        // Конструктор из блока и позиции
        private Index (StringItem si, int position)
        {
            this.si = si;
            this.position = position;
        }
    }

    private StringItem head; // начало связного списка

    //Конструктор по умолчанию
    public ListString()
    {
        1. Инициализация переменной head (null)
    }

    //Конструктор из ListString
    public ListString(ListString ls)
    {
        1. Инициализация переменной head равной ls.head (копирующий конструктор)
        2. Создать два узла StringItem (old: ls.head, new: head)
        3. Пока следующий элемент есть, двигаться по данному связному списку и создавать новые узлы в текущий список (копирующий конструктор)
    }

    //Конструктор из строки
    public ListString(String s)
    {
        Создать новый символьный массив charArray из строки (String.toCharArray())
        Если длина charArray меньше SIZE, просто создать новый StringItem и скопировать в него символьный массив (метод copy)
        Иначе:
            Из первых SIZE символов создаем новый узел head
            Длину строки уменьшаем на SIZE
            Пока длина строки больше SIZE:
                Создать новый узел в ListString и копировать в него 16 элементов символьного массива (метод copy)
    }

    // Найти фактическую длину связного списка, совмещая при этом полупустые блоки
    public int length()
    {
        Создать переменную int len = 0
        Пока блок есть
            Если следующий блок есть и суммарная длина текущего и следующего блока меньше SIZE
                Метод join для текущего блока
            Иначе
                len += размер текущего блока
                Текущий блок меняем на следующий
    }

    // Найти символ по индексу
    public char charAt(int index)
    {
        1. Найти блок и позицию в этом блоке (метод find)
        2. Если позиция не действительна, выбросить исключение
        3. Если блок == null, значит, что позиция в head, вернуть head.symbols[позиция]
        4. Иначе вернуть символ: блок.next.symbols[позиция]
    }

    // Заменить в строке символ в позиции index на символ ch
    public void setCharAt(int index, char ch)
    {
        1. Найти блок и позицию в этом блоке (метод find)
        2. Если позиция не действительна, выбросить исключение
        3. Если блок == null, значит, что позиция в head, head.symbols[позиция] = ch
        4. Иначе: блок.next.symbols[позиция] = ch
    }

    // Создать новый ListString (подстрока от start до end текущего)
    public ListString substring(int start, int end)
    {
        1. Если конец больше старта, выбросить исключение
        2. Найти блок и позицию для start (метод find)
        3. Если старта не существует, выбросить исключение
        4. Найти блок и позицию для end (метод find)
        5. Если конца не существует, брать до конца строки (меняем блок end (метод lastItem), индекс на размер этого блока)

        Если начало и конец в одном блоке, создать один узел и скопировать в него символьный массив (метод copy)
        Если начало и конец в разных блоках:
            Создать новый ListString
            head = new StringItem()
            Блок start копируется частично (метод copy от start до конца)
            Цикл по блокам до блока end
                Новые узлы создавать копирующим конструктором new StringItem(StringItem)
            Блок end копируется частично ((метод copy от 0 до end)
    }

    // Дойти до последнего блока
    private StringItem lastItem()
    {
        1. Пока есть следующий блок двигаться по связному списку
        2. Вернуть элемент, у которого next null
    }

    // Добавить в конец строки символ
    public void append(char ch)
    {
        1. Получить последний блок (метод lastItem)
        2. Проверить, есть ли в нем место
            True: добавить элемент в текущий массив
            False: создать следующий блок и записать в него этот символ
    }

    // Добавить в конец строку ListString
    public void append(ListString string)
    {
        1. Получить последний блок (метод lastItem)
        2. Перекинуть указатель next на string.head
    }

    // Добавить в конец строку String
    public void append(String string)
    {
        1. Преобразовать строку в список-строку new ListString(string)
        2. Получить последний блок (метод lastItem)
        3. Перекинуть указатель next на string.head
    }

    // Вставить в строку в позицию index строку ListString
    public void insert(int index, ListString string)
    {
        1. Найти предыдущий блок от нужного и позицию для индекса (метод find)
        Если индекс недействителен, выбросить исключение
        Если возвращенный блок == null, то нужный блок head
        2. Если блок head и индекс 0, перекинуть указатели
        3. Иначе если блок head, разделить (метод split) и перебросить указатели
        4. Иначе insert(Index, ListString)
    }

    // Вставить в строку в позицию index строку String
    public void insert(int index, String string)
    {
        1. Найти предыдущий блок от нужного и позицию для индекса (метод find)
        Если индекс недействителен, выбросить исключение
        Если возвращенный блок == null, то нужный блок head
        2. Преобразовать строку в список-строку new ListString(string)
        3. Если блок head и индекс 0, перекинуть указатели
        4. Иначе если блок head, разделить (метод split) и перебросить указатели
        5. Иначе insert(Index, ListString)
    }

    // insert закрытый с готовым индексом и строкой
    private void insert(Index index, ListString string)
    {
        1. Найти последний блок string
        2. Если индекс 0, перекинуть указатели
        3. Иначе нужный блок разделить по позиции (метод split) и перебросить указатели
    }

    // Преобразовать список-строку в строку
    public String toString()
    {
        1. Узнать длину списка-строки
        2. Выделить память под символьный массив
        3. Скопировать туда каждый узел списка-строки (цикл с методом copy)
        4. Вернуть new String(полученный символьный массив)
    }

    // Найти блок и позицию элемента по индексу

    private Index find(int i)
    {
        Создать переменные для учета текущего блока и предыдущего.
        Пока текущий блок есть:
            Если i больше размера текущего блока, то i -= size, иначе break
            Предыдущий блок заменяем на текущий, а текущий на следующий
        Если после цикла блок есть:
            Создать новый экзмепляр класса Index - index
            index.position = i
            index.si равен предыдущему блоку
            Вернуть index
        Вернуть Index(null, -1)
    }

    // Скопировать элементы одного символьного массива в другой
    private static void copy(char[] from, char[] to, int old_start, int length, int new_start)
    {
        Цикл от 0 до length:
            to[new_start + i] = from[old_start + i]
    }
}

//Реализовать класс исключения
public class IndexException extends RuntimeException
{
    int index; // в каком индексе ошибка

    // Конструктор исключения
    public IndexException()

    public IndexException(int index)
    {
        this.index = index;
    }

    // Сообщение ошибки
    public String toString()
    {
        return "Неверный индекс " + index;
    }
}